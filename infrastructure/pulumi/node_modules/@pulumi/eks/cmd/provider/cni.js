"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.vpcCniProviderFactory = exports.getBaseVpcCniYaml = exports.updateImage = void 0;
const dependencies_1 = require("../../dependencies");
const childProcess = require("child_process");
const crypto = require("crypto");
const fs = require("fs");
const jsyaml = require("js-yaml");
const path = require("path");
const process = require("process");
const tmp = require("tmp");
function updateImage(daemonSet, containerName, image) {
    for (const container of daemonSet.spec.template.spec.containers) {
        if (container.name === containerName) {
            container.image = image;
            return;
        }
    }
    throw new Error(`Container ${containerName} not found in daemonset`);
}
exports.updateImage = updateImage;
function computeVpcCniYaml(cniYamlText, args) {
    var _a;
    const cniYaml = jsyaml.loadAll(cniYamlText);
    // Rewrite the envvars for the CNI daemon set as per the inputs.
    const daemonSet = cniYaml.filter((o) => o.kind === "DaemonSet")[0];
    const env = daemonSet.spec.template.spec.containers[0].env;
    const initEnv = daemonSet.spec.template.spec.initContainers[0].env;
    const securityContext = daemonSet.spec.template.spec.containers[0].securityContext;
    if (args.nodePortSupport) {
        env.push({
            name: "AWS_VPC_CNI_NODE_PORT_SUPPORT",
            value: args.nodePortSupport ? "true" : "false",
        });
    }
    if (args.customNetworkConfig) {
        env.push({
            name: "AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG",
            value: args.customNetworkConfig ? "true" : "false",
        });
    }
    env.push({ name: "WARM_ENI_TARGET", value: `${(_a = args.warmEniTarget) !== null && _a !== void 0 ? _a : 1}` });
    if (args.warmIpTarget) {
        env.push({
            name: "WARM_IP_TARGET",
            value: args.warmIpTarget.toString(),
        });
    }
    if (args.warmPrefixTarget) {
        env.push({
            name: "WARM_PREFIX_TARGET",
            value: args.warmPrefixTarget.toString(),
        });
    }
    if (args.enableIpv6) {
        env.push({
            name: "ENABLE_IPv6",
            value: args.enableIpv6 ? "true" : "false",
        });
        initEnv.push({
            name: "ENABLE_IPv6",
            value: args.enableIpv6 ? "true" : "false",
        });
    }
    else {
        env.push({ name: "ENABLE_IPv6", value: "false" });
        initEnv.push({ name: "ENABLE_IPv6", value: "false" });
        env.push({ name: "ENABLE_IPv4", value: "true" });
        initEnv.push({ name: "ENABLE_IPv4", value: "true" });
    }
    if (args.enablePrefixDelegation) {
        env.push({
            name: "ENABLE_PREFIX_DELEGATION",
            value: args.enablePrefixDelegation ? "true" : "false",
        });
    }
    if (args.logLevel) {
        env.push({
            name: "AWS_VPC_K8S_CNI_LOGLEVEL",
            value: args.logLevel.toString(),
        });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_LOGLEVEL", value: "DEBUG" });
    }
    if (args.logFile) {
        env.push({
            name: "AWS_VPC_K8S_CNI_LOG_FILE",
            value: args.logFile.toString(),
        });
    }
    else {
        env.push({
            name: "AWS_VPC_K8S_CNI_LOG_FILE",
            value: "/host/var/log/aws-routed-eni/ipamd.log",
        });
    }
    if (args.vethPrefix) {
        env.push({
            name: "AWS_VPC_K8S_CNI_VETHPREFIX",
            value: args.vethPrefix.toString(),
        });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_VETHPREFIX", value: "eni" });
    }
    if (args.eniMtu) {
        env.push({ name: "AWS_VPC_ENI_MTU", value: args.eniMtu.toString() });
    }
    else {
        env.push({ name: "AWS_VPC_ENI_MTU", value: "9001" });
    }
    if (args.image) {
        updateImage(daemonSet, "aws-node", args.image.toString());
    }
    if (args.nodeAgentImage) {
        updateImage(daemonSet, "aws-eks-nodeagent", args.nodeAgentImage.toString());
    }
    if (args.initImage) {
        daemonSet.spec.template.spec.initContainers[0].image = args.initImage.toString();
    }
    if (args.eniConfigLabelDef) {
        env.push({
            name: "ENI_CONFIG_LABEL_DEF",
            value: args.eniConfigLabelDef.toString(),
        });
    }
    if (args.pluginLogLevel) {
        env.push({
            name: "AWS_VPC_K8S_PLUGIN_LOG_LEVEL",
            value: args.pluginLogLevel.toString(),
        });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_PLUGIN_LOG_LEVEL", value: "DEBUG" });
    }
    if (args.pluginLogFile) {
        env.push({
            name: "AWS_VPC_K8S_PLUGIN_LOG_FILE",
            value: args.pluginLogFile.toString(),
        });
    }
    else {
        env.push({
            name: "AWS_VPC_K8S_PLUGIN_LOG_FILE",
            value: "/var/log/aws-routed-eni/plugin.log",
        });
    }
    if (args.enablePodEni) {
        env.push({
            name: "ENABLE_POD_ENI",
            value: args.enablePodEni ? "true" : "false",
        });
    }
    else {
        env.push({ name: "ENABLE_POD_ENI", value: "false" });
    }
    if (args.disableTcpEarlyDemux) {
        initEnv.push({
            name: "DISABLE_TCP_EARLY_DEMUX",
            value: args.disableTcpEarlyDemux ? "true" : "false",
        });
    }
    else {
        initEnv.push({ name: "DISABLE_TCP_EARLY_DEMUX", value: "false" });
    }
    if (args.cniConfigureRpfilter) {
        env.push({
            name: "AWS_VPC_K8S_CNI_CONFIGURE_RPFILTER",
            value: args.cniConfigureRpfilter ? "true" : "false",
        });
    }
    if (args.cniCustomNetworkCfg) {
        env.push({
            name: "AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG",
            value: args.cniCustomNetworkCfg ? "true" : "false",
        });
    }
    else {
        env.push({
            name: "AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG",
            value: "false",
        });
    }
    // A user would usually specify externalSnat or cniExternalSnat NOT both
    if (args.cniExternalSnat && args.externalSnat) {
        throw new Error("Please specify one of `cniExternalSnat` or `externalSnat` in your VpcCniOptions");
    }
    if (args.externalSnat) {
        env.push({
            name: "AWS_VPC_K8S_CNI_EXTERNALSNAT",
            value: args.externalSnat ? "true" : "false",
        });
    }
    else if (args.cniExternalSnat) {
        env.push({
            name: "AWS_VPC_K8S_CNI_EXTERNALSNAT",
            value: args.cniExternalSnat ? "true" : "false",
        });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_EXTERNALSNAT", value: "false" });
    }
    if (args.securityContextPrivileged) {
        securityContext.privileged = args.securityContextPrivileged;
    }
    // Return the computed YAML.
    return cniYaml.map((o) => `---\n${jsyaml.dump(o)}`).join("");
}
function getBaseVpcCniYaml() {
    const yamlPath = path.join(__dirname, "../../cni/aws-k8s-cni.yaml");
    const cniYamlText = fs.readFileSync(yamlPath).toString();
    return cniYamlText;
}
exports.getBaseVpcCniYaml = getBaseVpcCniYaml;
function applyVpcCniYaml(args) {
    // Check to ensure that a compatible kubectl is installed, as we'll need it in order to deploy k8s resources below.
    (0, dependencies_1.assertCompatibleKubectlVersionExists)();
    const kubeconfig = typeof args.kubeconfig === "string" ? args.kubeconfig : JSON.stringify(args.kubeconfig);
    // Dump the kubeconfig to a file.
    const tmpKubeconfig = tmp.fileSync();
    fs.writeFileSync(tmpKubeconfig.fd, kubeconfig);
    // Compute the required CNI YAML and dump it to a file.
    const tmpYaml = tmp.fileSync();
    const computedCniManifest = computeVpcCniYaml(getBaseVpcCniYaml(), args);
    fs.writeFileSync(tmpYaml.fd, computedCniManifest);
    // Call kubectl to apply the YAML.
    childProcess.execSync(`kubectl apply -f ${tmpYaml.name}`, {
        env: Object.assign(Object.assign({}, process.env), { KUBECONFIG: tmpKubeconfig.name }),
    });
    return computedCniManifest;
}
/** @internal */
function vpcCniProviderFactory() {
    return {
        check: (urn, olds, news) => {
            let inputs = news;
            // Since this used to be implemented as a dynamic provider, if we have an old `__provider`
            // input, propagate it to the new inputs so the engine doesn't see a diff, to avoid any
            // unnecessary calls to `update`.
            if (olds.__provider && !news.__provider) {
                inputs = Object.assign(Object.assign({}, news), { __provider: olds.__provider });
            }
            return Promise.resolve({ inputs });
        },
        diff: (id, urn, olds, news) => {
            const computedCniManifest = computeVpcCniYaml(getBaseVpcCniYaml(), news);
            if (olds.manifest !== computedCniManifest) {
                return Promise.resolve({ changes: true });
            }
            return Promise.resolve({ changes: false });
        },
        create: (urn, inputs) => {
            try {
                const manifest = applyVpcCniYaml(inputs);
                return Promise.resolve({
                    id: crypto.randomBytes(8).toString("hex"),
                    outs: { manifest: manifest },
                });
            }
            catch (e) {
                return Promise.reject(e);
            }
        },
        update: (id, urn, olds, news) => {
            try {
                const manifest = applyVpcCniYaml(news);
                return Promise.resolve({ outs: { manifest: manifest } });
            }
            catch (e) {
                return Promise.reject(e);
            }
        },
        version: "", // ignored
    };
}
exports.vpcCniProviderFactory = vpcCniProviderFactory;
//# sourceMappingURL=cni.js.map